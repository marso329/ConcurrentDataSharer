\hypertarget{classBlockingQueue}{}\section{Blocking\+Queue$<$ T $>$ Class Template Reference}
\label{classBlockingQueue}\index{Blocking\+Queue$<$ T $>$@{Blocking\+Queue$<$ T $>$}}


\+\_\+\+T\+C\+P\+Send\+Queue = new \hyperlink{classBlockingQueue}{Blocking\+Queue$<$\+Queue\+Element\+Base$\ast$$>$(255)}; \+\_\+\+T\+C\+P\+Send\+Queue-\/$>$put(new Queue\+Element\+Base() );  




{\ttfamily \#include $<$Blocking\+Queue.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classBlockingQueue_a42f821a61ba22ba27e6d1a434ab27eb2}{Blocking\+Queue} ()
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\hyperlink{classBlockingQueue_adfb84eb73f882a364c8f4cb325b22a1a}{Blocking\+Queue} (std\+::size\+\_\+t capacity)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
void \hyperlink{classBlockingQueue_aeda6a5448ed9b96a56fa1143e6e8ad1c}{Put} (const T \&task)
\begin{DoxyCompactList}\small\item\em put an element in the queue, blocks if full \end{DoxyCompactList}\item 
T \hyperlink{classBlockingQueue_a38dd122eba62f8b5d7ddc1aae266e8da}{Take} ()
\begin{DoxyCompactList}\small\item\em take an element from the queue, blocks if empty \end{DoxyCompactList}\item 
T \hyperlink{classBlockingQueue_a1890f7159b58b97ca1cade42bce9e982}{Front} ()
\begin{DoxyCompactList}\small\item\em returns the front element(been longest in the queue), does not pop, blocks if empty \end{DoxyCompactList}\item 
T \hyperlink{classBlockingQueue_ad2e79734669baee7eeb90e43e9e5d6b9}{Back} ()
\begin{DoxyCompactList}\small\item\em returns the back element(been shortest in the queue), does not pop, blocks if empty \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{classBlockingQueue_acf02cc9e5671442f6f66c156d9cbe431}{Size} ()
\begin{DoxyCompactList}\small\item\em returns the number of elements in the queue \end{DoxyCompactList}\item 
bool \hyperlink{classBlockingQueue_ae7884eb98569730e5cea0e443d5bb661}{Empty} ()
\begin{DoxyCompactList}\small\item\em returns true if the queue is empty \end{DoxyCompactList}\item 
void \hyperlink{classBlockingQueue_ab3d6fd8cc72986de54213ebdef01245d}{Set\+Capacity} (const size\+\_\+t capacity)
\begin{DoxyCompactList}\small\item\em sets the capacity of the queue \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\\*
class Blocking\+Queue$<$ T $>$}

\+\_\+\+T\+C\+P\+Send\+Queue = new \hyperlink{classBlockingQueue}{Blocking\+Queue$<$\+Queue\+Element\+Base$\ast$$>$(255)}; \+\_\+\+T\+C\+P\+Send\+Queue-\/$>$put(new Queue\+Element\+Base() ); 

This is a blocking thread safe F\+I\+FO queue

\begin{DoxyAuthor}{Author}
Martin Soderen
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2017/04/147 00\+:00\+:00
\end{DoxyDate}
Contact\+: \href{mailto:martin.soderen@gmail.com}{\tt martin.\+soderen@gmail.\+com}

Created on\+: Fri Apr 14 00\+:00\+:00 2017

\begin{DoxyParagraph}{Id}

\end{DoxyParagraph}


\subsection{Constructor \& Destructor Documentation}
\index{Blocking\+Queue@{Blocking\+Queue}!Blocking\+Queue@{Blocking\+Queue}}
\index{Blocking\+Queue@{Blocking\+Queue}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Blocking\+Queue()}{BlockingQueue()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf Blocking\+Queue}$<$ T $>$\+::{\bf Blocking\+Queue} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classBlockingQueue_a42f821a61ba22ba27e6d1a434ab27eb2}{}\label{classBlockingQueue_a42f821a61ba22ba27e6d1a434ab27eb2}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em $<$\+T$>$} & template \\
\hline
\end{DoxyParams}
\index{Blocking\+Queue@{Blocking\+Queue}!Blocking\+Queue@{Blocking\+Queue}}
\index{Blocking\+Queue@{Blocking\+Queue}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Blocking\+Queue(std\+::size\+\_\+t capacity)}{BlockingQueue(std::size_t capacity)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf Blocking\+Queue}$<$ T $>$\+::{\bf Blocking\+Queue} (
\begin{DoxyParamCaption}
\item[{std\+::size\+\_\+t}]{capacity}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classBlockingQueue_adfb84eb73f882a364c8f4cb325b22a1a}{}\label{classBlockingQueue_adfb84eb73f882a364c8f4cb325b22a1a}


Constructor. 


\begin{DoxyParams}{Parameters}
{\em $<$\+T$>$} & template \\
\hline
{\em capacity} & how many elements you can fill \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{Blocking\+Queue@{Blocking\+Queue}!Back@{Back}}
\index{Back@{Back}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Back()}{Back()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ T {\bf Blocking\+Queue}$<$ T $>$\+::Back (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_ad2e79734669baee7eeb90e43e9e5d6b9}{}\label{classBlockingQueue_ad2e79734669baee7eeb90e43e9e5d6b9}


returns the back element(been shortest in the queue), does not pop, blocks if empty 

\begin{DoxyReturn}{Returns}
element 
\end{DoxyReturn}
\index{Blocking\+Queue@{Blocking\+Queue}!Empty@{Empty}}
\index{Empty@{Empty}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Empty()}{Empty()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool {\bf Blocking\+Queue}$<$ T $>$\+::Empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_ae7884eb98569730e5cea0e443d5bb661}{}\label{classBlockingQueue_ae7884eb98569730e5cea0e443d5bb661}


returns true if the queue is empty 

\begin{DoxyReturn}{Returns}
bool if empty 
\end{DoxyReturn}
\index{Blocking\+Queue@{Blocking\+Queue}!Front@{Front}}
\index{Front@{Front}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Front()}{Front()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ T {\bf Blocking\+Queue}$<$ T $>$\+::Front (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_a1890f7159b58b97ca1cade42bce9e982}{}\label{classBlockingQueue_a1890f7159b58b97ca1cade42bce9e982}


returns the front element(been longest in the queue), does not pop, blocks if empty 

\begin{DoxyReturn}{Returns}
element 
\end{DoxyReturn}
\index{Blocking\+Queue@{Blocking\+Queue}!Put@{Put}}
\index{Put@{Put}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Put(const T \&task)}{Put(const T &task)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ void {\bf Blocking\+Queue}$<$ T $>$\+::Put (
\begin{DoxyParamCaption}
\item[{const T \&}]{task}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_aeda6a5448ed9b96a56fa1143e6e8ad1c}{}\label{classBlockingQueue_aeda6a5448ed9b96a56fa1143e6e8ad1c}


put an element in the queue, blocks if full 


\begin{DoxyParams}{Parameters}
{\em task} & element to put in queue \\
\hline
\end{DoxyParams}
\index{Blocking\+Queue@{Blocking\+Queue}!Set\+Capacity@{Set\+Capacity}}
\index{Set\+Capacity@{Set\+Capacity}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Set\+Capacity(const size\+\_\+t capacity)}{SetCapacity(const size_t capacity)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void {\bf Blocking\+Queue}$<$ T $>$\+::Set\+Capacity (
\begin{DoxyParamCaption}
\item[{const size\+\_\+t}]{capacity}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_ab3d6fd8cc72986de54213ebdef01245d}{}\label{classBlockingQueue_ab3d6fd8cc72986de54213ebdef01245d}


sets the capacity of the queue 


\begin{DoxyParams}{Parameters}
{\em capacity} & the new capacity of the queue \\
\hline
\end{DoxyParams}
\index{Blocking\+Queue@{Blocking\+Queue}!Size@{Size}}
\index{Size@{Size}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Size()}{Size()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ size\+\_\+t {\bf Blocking\+Queue}$<$ T $>$\+::Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_acf02cc9e5671442f6f66c156d9cbe431}{}\label{classBlockingQueue_acf02cc9e5671442f6f66c156d9cbe431}


returns the number of elements in the queue 

\begin{DoxyReturn}{Returns}
size of queue 
\end{DoxyReturn}
\index{Blocking\+Queue@{Blocking\+Queue}!Take@{Take}}
\index{Take@{Take}!Blocking\+Queue@{Blocking\+Queue}}
\subsubsection[{\texorpdfstring{Take()}{Take()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ T {\bf Blocking\+Queue}$<$ T $>$\+::Take (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classBlockingQueue_a38dd122eba62f8b5d7ddc1aae266e8da}{}\label{classBlockingQueue_a38dd122eba62f8b5d7ddc1aae266e8da}


take an element from the queue, blocks if empty 

\begin{DoxyReturn}{Returns}
element 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/martin/repositories/\+Concurrent\+Data\+Sharer/include/Blocking\+Queue.\+h\item 
/home/martin/repositories/\+Concurrent\+Data\+Sharer/src/Blocking\+Queue.\+cpp\end{DoxyCompactItemize}
